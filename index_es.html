<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Colección de Códigos en Python</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #fafafa;
            padding: 2rem;
            line-height: 1.6;
        }
        h1 {
            text-align: center;
        }
        section {
            margin-bottom: 3rem;
        }
        pre {
            background: #f4f4f4;
            padding: 1rem;
            border-left: 4px solid #007acc;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        code {
            font-family: Consolas, monospace;
        }
    </style>
</head>
<body>
    <h1>Archivos de Código en Python</h1>
    
    <section>
        <h2>Archivo: interpolacion_lineal.py</h2>
        <pre><code>
import matplotlib.pyplot as plt
import numpy as np

x0, f_x0 = 3, 19
x1, f_x1 = 5, 99
x = 4 

f_x = f_x0 + (f_x1 - f_x0) * (x - x0) / (x1 - x0)

print(f"Valor estimado de f(4) {f_x}")

# Plotting the known points and the interpolated point
x_vals = np.array([x0, x1])
y_vals = np.array([f_x0, f_x1])

plt.plot(x_vals, y_vals, 'bo-', label='Datos conocidos')
plt.plot(x, f_x, 'ro', label=f'Interpolación lineal f({x})={f_x:.2f}')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Interpolación Lineal')
plt.legend()
plt.grid(True)
plt.show()</code></pre>
    </section>
    
    <section>
        <h2>Archivo: Interpolacion_cuadratica.py</h2>
        <pre><code>import matplotlib.pyplot as plt
import numpy as np

x0, f_x0 = 2, 6
x1, f_x1 = 3, 19
x2, f_x2 = 5, 99
x = 4  

A = np.array([
    [x0**2, x0, 1],
    [x1**2, x1, 1],
    [x2**2, x2, 1]
])
B = np.array([f_x0, f_x1, f_x2])

a, b, c = np.linalg.solve(A, B)

f_x = a * x**2 + b * x + c
print(f"Estimated value of f(4) using quadratic interpolation with Cramer's rule: {f_x}")

x_valor = np.array([x0, x1, x2])
y_valor = np.array([f_x0, f_x1, f_x2])
xp = np.linspace(min(x_valor), max(x_valor), 100)
yp = a * xp**2 + b * xp + c

plt.plot(x_valor, y_valor, 'bo', label='Datos conocidos')
plt.plot(x, f_x, 'ro', label=f'Interpolación cuadrática f({x})={f_x:.2f}')
plt.plot(xp, yp, 'b--', label='Polinomio interpolado')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Interpolación Cuadrática (Regla de Cramer)')
plt.legend()
plt.grid(True)
plt.show()</code></pre>
    </section>
    
    <section>
        <h2>Archivo: Tarea2_Pinero_Secante.py</h2>
        <pre><code>import numpy as np
import matplotlib.pyplot as plt

x0 = -0.3
x_1 = 0.5

f = lambda t: 8 * t * np.sin(t) * np.exp(-t) - 1
error = lambda a, b: np.abs(b-a/b)

for i in range(5):
    x1 = x0 - ((f(x0) * (x_1 - x0)) / (f(x_1) - f(x0)))

    print(f'i = {i+1} | x0 = {x0} | x1 = {x1} | error = {error(x_1,x0)}')

    x_1, x0 = x0, x1

x = np.linspace(-3,5,500)
y = f(x)

plt.plot(x,y,label='f(x) = 8xsen(x)e^-x - 1', color='red', linestyle=':')
plt.axhline(0,color='black',linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5, linestyle='--')
plt.xlabel('eje x')
plt.ylabel('eje y')
plt.title('Gráfica Secante')
plt.legend()
plt.grid()
plt.show()</code></pre>
    </section>
    
    <section>
        <h2>Archivo: Tarea3_Pinero_FalsaPosicion.py</h2>
        <pre><code>import numpy as np
import matplotlib.pyplot as plt

a = -3
b = -2

f = lambda t: 2 * t * np.cos(2 * t) - (t + 1) ** 2
error_relativo = lambda xi,xh: (np.abs(xi - xh))*100

xi_prev = None

for i in range(5):
    y = b - ((f(b)*(a-b))/(f(a)-f(b)))
    if f(y) < 0:
        a = y
    else:
        b = y
    if xi_prev is not None:
        error = error_relativo(y,xi_prev)
    else:
        error = None
    print(f'i = {i+1} | a = {a:.4f} | b = {b:.4f} | f(a) = {f(a):.4f} | f(b) = {f(b):.4f} | xi = {y} | f(xi) = {f(y):.4f} | error = {error}% \n')

    xi_prev = y

x = np.linspace(-3,-2,500)

y = f(x)

plt.plot(x,y,label='2xcos(2x)-(x+1)^2', color='red', linestyle=':')
plt.axhline(0,color='black',linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5, linestyle='--')
plt.xlabel('eje x')
plt.ylabel('eje y')
plt.title('Gráfica Falsa Posicion')
plt.legend()
plt.grid()
plt.show()</code></pre>
    </section>
    
    <section>
        <h2>Archivo: regresion_lineal.py</h2>
        <pre><code>import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

url = "https://raw.githubusercontent.com/ybifoundation/Dataset/main/Salary%20Data.csv"
datos = pd.read_csv(url)

datos_numericos = datos.select_dtypes(include='number')

Xi = datos_numericos.iloc[0]
Yi = datos_numericos.iloc[1]

suma_xi = Xi.sum()
suma_yi = Yi.sum()
suma_xiyi = (Xi * Yi).sum()
suma_xi2 = (Xi ** 2).sum()
cuadrado_sumaxi = suma_xi ** 2
n = len(Xi)

a = (n * suma_xiyi - suma_yi * suma_xi2) / (cuadrado_sumaxi - n * suma_xi2)
b = (suma_xi * suma_xiyi - suma_yi * suma_xi2) / (cuadrado_sumaxi - n * suma_xi2)

tiempo1 = a + (b * 15)
tiempo2 = a + (b * 30)
tiempo3 = a + (b * 50)

print(f"y = {a:.3f} + {b:.3f}x")
print(f"Salario después de 15 años = {tiempo1:.3f}")
print(f"Salario después de 30 años = {tiempo2:.3f}")
print(f"Salario después de 50 años = {tiempo3:.3f}")

x_vals = np.array([0, 60])  
y_vals = a + b * x_vals

x_pred = np.array([15, 30, 50])
y_pred = a + b * x_pred

plt.plot(x_vals, y_vals, 'b-', label='Línea de regresión')
plt.plot(x_pred, y_pred, 'ro', label='Predicciones')
plt.title('Regresión Lineal del Salario')
plt.xlabel('Experiencia en años')
plt.ylabel('Salario')
plt.grid(True)
plt.legend()
plt.show()


</code></pre>
    </section>
    
    <section>
        <h2>Archivo: Tarea2_Pinero_Newton-Raphson.py</h2>
        <pre><code>import numpy as np
import matplotlib.pyplot as plt

x = 0.3
n = 5

f = lambda t: 8 * t * np.sin(t) * np.exp(-t) - 1
df = lambda t: (8 * np.exp(-t) - 8 * t * np.exp(-t)) * np.sin(t) + (8 * t * np.exp(-t)) * np.cos(t)
error = lambda x0 , x1: np.abs(x1-x0/x1)

for i in range(n):
    x = x - f(x)/df(x)
    print(f'i = {i+1} | x = {x} | error = {error(x,x-1)}')

x = np.linspace(-3,5,500)
y = f(x)
z = df(x)

plt.plot(x,y,label='f(x) = 8xsen(x)e^-x - 1', color='red', linestyle=':')
plt.plot(x,z,label="f'(x) = (8e^-x - 8xe^-x)sen(x) + (8xe^-x)cos(x)", color='blue', linestyle='-')
plt.axhline(0,color='black',linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5, linestyle='--')
plt.xlabel('eje x')
plt.ylabel('eje y')
plt.title('Gráfica Newton-Raphson')
plt.legend()
plt.grid()
plt.show()
</code></pre>
    </section>
    
    <section>
        <h2>Archivo: Graficas_Tarea1_Pinero.py</h2>
        <pre><code>import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-20, 20, 200)

y1 = x**2 + 7*x + 2
y2 = np.sin(x) + 6*x + 3
y3 = np.sqrt(np.abs(x)) + 4*x

plt.figure(figsize=(10, 6))
plt.plot(x, y1, color='red',linestyle='--',label=r"$x^2 + 7x + 2$")
plt.plot(x, y2, color='purple',linestyle='-',label=r"$\sin(x) + 6x + 3$")
plt.plot(x, y3, color='green',linestyle='-.',label=r"$\sqrt{|x|} + 4x$")

plt.xlabel("x")
plt.ylabel("y")
plt.title("Gráfica de 3 funciones")
plt.axhline(0, color="black", linewidth=0.5)
plt.axvline(0, color="black", linewidth=0.5)
plt.legend()
plt.grid()

plt.show()
</code></pre>
    </section>
    
    <section>
        <h2>Archivo: Tarea2_Pinero_Biseccion.py</h2>
        <pre><code>import numpy as np
import matplotlib.pyplot as plt

a = -3
b = -2
n = 6
vr = -2.1913
f = lambda t: 2 * t * np.cos(2 * t) - (t + 1) ** 2

error_relativo= lambda xr, va: (np.abs(xr - va) / np.abs(va)) * 100

for i in range(5):
    xi = (a+b)/2
    fa=f(a)
    fxi=f(xi)
    if fa*fxi<0:
        b=xi
    else:
        a=xi
    print(f'i = {i+1} | a = {a} | b = {b} | xi = {xi} | error = {error_relativo(xi,vr)}% \n')

x = np.linspace(-3,-2,500)
y = f(x)

plt.plot(x,y,label='2xcos(2x)-(x+1)^2', color='red', linestyle=':')
plt.axhline(0,color='black',linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5, linestyle='--')
plt.xlabel('eje x')
plt.ylabel('eje y')
plt.title('Gráfica Bisección')
plt.legend()
plt.grid()
plt.show()</code></pre>
    </section>
    
    <section>
        <h2>Archivo: Tarea3_Pinero_Birge-Vieta.py</h2>
        <pre><code>import numpy as np
import matplotlib.pyplot as plt

def division_sintetica(coef, xi):
    n = len(coef)
    b = [coef[0]]
    for i in range(1, n):
        b.append(b[i - 1] * xi + coef[i])

    c = [b[0]]
    for i in range(1, n - 1):
        c.append(c[i - 1] * xi + b[i])

    return b, c

coeficientes = [1, -5, 5, -1]
x0 = 0.8

error = lambda a, b: np.abs(b-a/b)

for j in range(5):
    y = x0
    valor_b, valor_c = division_sintetica(coeficientes, y)
    x1 = x0 - (valor_b[3] / valor_c[2])
    x0 = x1
    error_relativo = error(x1, x0)
    print(f'i = {j+1} | x0 = {x0} | xi = {x1} | error = {error_relativo}% \n')

f = lambda t: (t ** 3) - (5 * (t ** 2)) + (5 * t) -1

x = np.linspace(-20,20,500)

y = f(x)

plt.plot(x,y,label='t^3 - 5t^2 + 5t - 1', color='red', linestyle=':')
plt.axhline(0,color='black',linewidth=0.5)
plt.axvline(0, color='black', linewidth=0.5, linestyle='--')
plt.xlabel('eje x')
plt.ylabel('eje y')
plt.title('Gráfica Birge-Vieta')
plt.legend()
plt.grid()
plt.show()





</code></pre>
    </section>
    
    <section>
        <h2>Archivo: interpolacion_Newton.py</h2>
        <pre><code>import matplotlib.pyplot as plt
import numpy as np

x_valor = np.array([1, 2, 3, 5, 7])
y_valor = np.array([3, 6, 19, 99, 291])

def diferencias_divididas(x, y):
    n = len(x)
    coef = np.copy(y).astype(float)
    for j in range(1, n):
        coef[j:] = (coef[j:] - coef[j-1:-1]) / (x[j:] - x[:n-j])
    return coef

def polinomio(x_dato, coeffs, x):
    n = len(coeffs)
    resultado = coeffs[0]
    for i in range(1, n):
        term = coeffs[i]
        for j in range(i):
            term *= (x - x_dato[j])
        resultado += term
    return resultado

coeffs = diferencias_divididas(x_valor, y_valor)

x_plot = np.linspace(min(x_valor), max(x_valor), 200)
y_plot = [polinomio(x_valor, coeffs, xi) for xi in x_plot]

plt.figure()
plt.plot(x_valor, y_valor, 'bo', label='Datos conocidos')
plt.plot(x_plot, y_plot, 'g-', label='Interpolación de Newton')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Interpolación de Newton (Grado 4)')
plt.legend()
plt.grid(True)
plt.show()
</code></pre>
    </section>
    
</body>
</html>
